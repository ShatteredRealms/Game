#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sro/characters/characters.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sro_2fcharacters_2fcharacters_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sro_2fcharacters_2fcharacters_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sro/globals.pb.h"
#include "google/api/annotations.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sro_2fcharacters_2fcharacters_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sro_2fcharacters_2fcharacters_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sro_2fcharacters_2fcharacters_2eproto;
namespace sro {
namespace characters {
class AddPlayTimeRequest;
struct AddPlayTimeRequestDefaultTypeInternal;
extern AddPlayTimeRequestDefaultTypeInternal _AddPlayTimeRequest_default_instance_;
class CharacterResponse;
struct CharacterResponseDefaultTypeInternal;
extern CharacterResponseDefaultTypeInternal _CharacterResponse_default_instance_;
class CharacterTarget;
struct CharacterTargetDefaultTypeInternal;
extern CharacterTargetDefaultTypeInternal _CharacterTarget_default_instance_;
class CharactersResponse;
struct CharactersResponseDefaultTypeInternal;
extern CharactersResponseDefaultTypeInternal _CharactersResponse_default_instance_;
class CreateCharacterRequest;
struct CreateCharacterRequestDefaultTypeInternal;
extern CreateCharacterRequestDefaultTypeInternal _CreateCharacterRequest_default_instance_;
class EditCharacterRequest;
struct EditCharacterRequestDefaultTypeInternal;
extern EditCharacterRequestDefaultTypeInternal _EditCharacterRequest_default_instance_;
class Gender;
struct GenderDefaultTypeInternal;
extern GenderDefaultTypeInternal _Gender_default_instance_;
class Genders;
struct GendersDefaultTypeInternal;
extern GendersDefaultTypeInternal _Genders_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class PlayTimeResponse;
struct PlayTimeResponseDefaultTypeInternal;
extern PlayTimeResponseDefaultTypeInternal _PlayTimeResponse_default_instance_;
class Realm;
struct RealmDefaultTypeInternal;
extern RealmDefaultTypeInternal _Realm_default_instance_;
class Realms;
struct RealmsDefaultTypeInternal;
extern RealmsDefaultTypeInternal _Realms_default_instance_;
}  // namespace characters
}  // namespace sro
PROTOBUF_NAMESPACE_OPEN
template<> ::sro::characters::AddPlayTimeRequest* Arena::CreateMaybeMessage<::sro::characters::AddPlayTimeRequest>(Arena*);
template<> ::sro::characters::CharacterResponse* Arena::CreateMaybeMessage<::sro::characters::CharacterResponse>(Arena*);
template<> ::sro::characters::CharacterTarget* Arena::CreateMaybeMessage<::sro::characters::CharacterTarget>(Arena*);
template<> ::sro::characters::CharactersResponse* Arena::CreateMaybeMessage<::sro::characters::CharactersResponse>(Arena*);
template<> ::sro::characters::CreateCharacterRequest* Arena::CreateMaybeMessage<::sro::characters::CreateCharacterRequest>(Arena*);
template<> ::sro::characters::EditCharacterRequest* Arena::CreateMaybeMessage<::sro::characters::EditCharacterRequest>(Arena*);
template<> ::sro::characters::Gender* Arena::CreateMaybeMessage<::sro::characters::Gender>(Arena*);
template<> ::sro::characters::Genders* Arena::CreateMaybeMessage<::sro::characters::Genders>(Arena*);
template<> ::sro::characters::Location* Arena::CreateMaybeMessage<::sro::characters::Location>(Arena*);
template<> ::sro::characters::PlayTimeResponse* Arena::CreateMaybeMessage<::sro::characters::PlayTimeResponse>(Arena*);
template<> ::sro::characters::Realm* Arena::CreateMaybeMessage<::sro::characters::Realm>(Arena*);
template<> ::sro::characters::Realms* Arena::CreateMaybeMessage<::sro::characters::Realms>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sro {
namespace characters {

// ===================================================================

class PlayTimeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.PlayTimeResponse) */ {
 public:
  inline PlayTimeResponse() : PlayTimeResponse(nullptr) {}
  ~PlayTimeResponse() override;
  explicit constexpr PlayTimeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayTimeResponse(const PlayTimeResponse& from);
  PlayTimeResponse(PlayTimeResponse&& from) noexcept
    : PlayTimeResponse() {
    *this = ::std::move(from);
  }

  inline PlayTimeResponse& operator=(const PlayTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayTimeResponse& operator=(PlayTimeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayTimeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayTimeResponse* internal_default_instance() {
    return reinterpret_cast<const PlayTimeResponse*>(
               &_PlayTimeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayTimeResponse& a, PlayTimeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayTimeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayTimeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayTimeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayTimeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayTimeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayTimeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayTimeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.PlayTimeResponse";
  }
  protected:
  explicit PlayTimeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // uint64 time = 1;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.PlayTimeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class AddPlayTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.AddPlayTimeRequest) */ {
 public:
  inline AddPlayTimeRequest() : AddPlayTimeRequest(nullptr) {}
  ~AddPlayTimeRequest() override;
  explicit constexpr AddPlayTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPlayTimeRequest(const AddPlayTimeRequest& from);
  AddPlayTimeRequest(AddPlayTimeRequest&& from) noexcept
    : AddPlayTimeRequest() {
    *this = ::std::move(from);
  }

  inline AddPlayTimeRequest& operator=(const AddPlayTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPlayTimeRequest& operator=(AddPlayTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPlayTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPlayTimeRequest* internal_default_instance() {
    return reinterpret_cast<const AddPlayTimeRequest*>(
               &_AddPlayTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddPlayTimeRequest& a, AddPlayTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPlayTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPlayTimeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPlayTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPlayTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPlayTimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddPlayTimeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPlayTimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.AddPlayTimeRequest";
  }
  protected:
  explicit AddPlayTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .sro.characters.CharacterTarget character = 1;
  bool has_character() const;
  private:
  bool _internal_has_character() const;
  public:
  void clear_character();
  const ::sro::characters::CharacterTarget& character() const;
  PROTOBUF_NODISCARD ::sro::characters::CharacterTarget* release_character();
  ::sro::characters::CharacterTarget* mutable_character();
  void set_allocated_character(::sro::characters::CharacterTarget* character);
  private:
  const ::sro::characters::CharacterTarget& _internal_character() const;
  ::sro::characters::CharacterTarget* _internal_mutable_character();
  public:
  void unsafe_arena_set_allocated_character(
      ::sro::characters::CharacterTarget* character);
  ::sro::characters::CharacterTarget* unsafe_arena_release_character();

  // uint64 time = 2;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.AddPlayTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sro::characters::CharacterTarget* character_;
  uint64_t time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class CreateCharacterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.CreateCharacterRequest) */ {
 public:
  inline CreateCharacterRequest() : CreateCharacterRequest(nullptr) {}
  ~CreateCharacterRequest() override;
  explicit constexpr CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCharacterRequest(const CreateCharacterRequest& from);
  CreateCharacterRequest(CreateCharacterRequest&& from) noexcept
    : CreateCharacterRequest() {
    *this = ::std::move(from);
  }

  inline CreateCharacterRequest& operator=(const CreateCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCharacterRequest& operator=(CreateCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCharacterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCharacterRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCharacterRequest*>(
               &_CreateCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateCharacterRequest& a, CreateCharacterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCharacterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCharacterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCharacterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCharacterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCharacterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCharacterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCharacterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.CreateCharacterRequest";
  }
  protected:
  explicit CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGenderFieldNumber = 3,
    kRealmFieldNumber = 4,
    kOwnerFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string gender = 3;
  void clear_gender();
  const std::string& gender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* gender);
  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(const std::string& value);
  std::string* _internal_mutable_gender();
  public:

  // string realm = 4;
  void clear_realm();
  const std::string& realm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* realm);
  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(const std::string& value);
  std::string* _internal_mutable_realm();
  public:

  // .sro.UserTarget owner = 1;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::sro::UserTarget& owner() const;
  PROTOBUF_NODISCARD ::sro::UserTarget* release_owner();
  ::sro::UserTarget* mutable_owner();
  void set_allocated_owner(::sro::UserTarget* owner);
  private:
  const ::sro::UserTarget& _internal_owner() const;
  ::sro::UserTarget* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::sro::UserTarget* owner);
  ::sro::UserTarget* unsafe_arena_release_owner();

  // @@protoc_insertion_point(class_scope:sro.characters.CreateCharacterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
  ::sro::UserTarget* owner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class CharacterTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.CharacterTarget) */ {
 public:
  inline CharacterTarget() : CharacterTarget(nullptr) {}
  ~CharacterTarget() override;
  explicit constexpr CharacterTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterTarget(const CharacterTarget& from);
  CharacterTarget(CharacterTarget&& from) noexcept
    : CharacterTarget() {
    *this = ::std::move(from);
  }

  inline CharacterTarget& operator=(const CharacterTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterTarget& operator=(CharacterTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterTarget& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kId = 1,
    kName = 2,
    TARGET_NOT_SET = 0,
  };

  static inline const CharacterTarget* internal_default_instance() {
    return reinterpret_cast<const CharacterTarget*>(
               &_CharacterTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CharacterTarget& a, CharacterTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CharacterTarget& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.CharacterTarget";
  }
  protected:
  explicit CharacterTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:sro.characters.CharacterTarget)
 private:
  class _Internal;
  void set_has_id();
  void set_has_name();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TargetUnion {
    constexpr TargetUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint64_t id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  } target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class EditCharacterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.EditCharacterRequest) */ {
 public:
  inline EditCharacterRequest() : EditCharacterRequest(nullptr) {}
  ~EditCharacterRequest() override;
  explicit constexpr EditCharacterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCharacterRequest(const EditCharacterRequest& from);
  EditCharacterRequest(EditCharacterRequest&& from) noexcept
    : EditCharacterRequest() {
    *this = ::std::move(from);
  }

  inline EditCharacterRequest& operator=(const EditCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCharacterRequest& operator=(EditCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCharacterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCharacterRequest* internal_default_instance() {
    return reinterpret_cast<const EditCharacterRequest*>(
               &_EditCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EditCharacterRequest& a, EditCharacterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCharacterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCharacterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCharacterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCharacterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCharacterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditCharacterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCharacterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.EditCharacterRequest";
  }
  protected:
  explicit EditCharacterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 3,
    kNewNameFieldNumber = 4,
    kGenderFieldNumber = 5,
    kRealmFieldNumber = 6,
    kTargetFieldNumber = 1,
    kLocationFieldNumber = 8,
    kPlayTimeFieldNumber = 7,
  };
  // optional string owner_id = 3;
  bool has_owner_id() const;
  private:
  bool _internal_has_owner_id() const;
  public:
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // optional string new_name = 4;
  bool has_new_name() const;
  private:
  bool _internal_has_new_name() const;
  public:
  void clear_new_name();
  const std::string& new_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_name();
  PROTOBUF_NODISCARD std::string* release_new_name();
  void set_allocated_new_name(std::string* new_name);
  private:
  const std::string& _internal_new_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(const std::string& value);
  std::string* _internal_mutable_new_name();
  public:

  // optional string gender = 5;
  bool has_gender() const;
  private:
  bool _internal_has_gender() const;
  public:
  void clear_gender();
  const std::string& gender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* gender);
  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(const std::string& value);
  std::string* _internal_mutable_gender();
  public:

  // optional string realm = 6;
  bool has_realm() const;
  private:
  bool _internal_has_realm() const;
  public:
  void clear_realm();
  const std::string& realm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* realm);
  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(const std::string& value);
  std::string* _internal_mutable_realm();
  public:

  // .sro.characters.CharacterTarget target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::sro::characters::CharacterTarget& target() const;
  PROTOBUF_NODISCARD ::sro::characters::CharacterTarget* release_target();
  ::sro::characters::CharacterTarget* mutable_target();
  void set_allocated_target(::sro::characters::CharacterTarget* target);
  private:
  const ::sro::characters::CharacterTarget& _internal_target() const;
  ::sro::characters::CharacterTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::sro::characters::CharacterTarget* target);
  ::sro::characters::CharacterTarget* unsafe_arena_release_target();

  // optional .sro.characters.Location location = 8;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::sro::characters::Location& location() const;
  PROTOBUF_NODISCARD ::sro::characters::Location* release_location();
  ::sro::characters::Location* mutable_location();
  void set_allocated_location(::sro::characters::Location* location);
  private:
  const ::sro::characters::Location& _internal_location() const;
  ::sro::characters::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::sro::characters::Location* location);
  ::sro::characters::Location* unsafe_arena_release_location();

  // optional uint64 play_time = 7;
  bool has_play_time() const;
  private:
  bool _internal_has_play_time() const;
  public:
  void clear_play_time();
  uint64_t play_time() const;
  void set_play_time(uint64_t value);
  private:
  uint64_t _internal_play_time() const;
  void _internal_set_play_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.EditCharacterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
  ::sro::characters::CharacterTarget* target_;
  ::sro::characters::Location* location_;
  uint64_t play_time_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class CharacterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.CharacterResponse) */ {
 public:
  inline CharacterResponse() : CharacterResponse(nullptr) {}
  ~CharacterResponse() override;
  explicit constexpr CharacterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterResponse(const CharacterResponse& from);
  CharacterResponse(CharacterResponse&& from) noexcept
    : CharacterResponse() {
    *this = ::std::move(from);
  }

  inline CharacterResponse& operator=(const CharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterResponse& operator=(CharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterResponse* internal_default_instance() {
    return reinterpret_cast<const CharacterResponse*>(
               &_CharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CharacterResponse& a, CharacterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CharacterResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.CharacterResponse";
  }
  protected:
  explicit CharacterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 2,
    kNameFieldNumber = 3,
    kGenderFieldNumber = 4,
    kRealmFieldNumber = 5,
    kLocationFieldNumber = 8,
    kIdFieldNumber = 1,
    kPlayTimeFieldNumber = 6,
  };
  // string owner = 2;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string gender = 4;
  void clear_gender();
  const std::string& gender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* gender);
  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(const std::string& value);
  std::string* _internal_mutable_gender();
  public:

  // string realm = 5;
  void clear_realm();
  const std::string& realm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* realm);
  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(const std::string& value);
  std::string* _internal_mutable_realm();
  public:

  // .sro.characters.Location location = 8;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::sro::characters::Location& location() const;
  PROTOBUF_NODISCARD ::sro::characters::Location* release_location();
  ::sro::characters::Location* mutable_location();
  void set_allocated_location(::sro::characters::Location* location);
  private:
  const ::sro::characters::Location& _internal_location() const;
  ::sro::characters::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::sro::characters::Location* location);
  ::sro::characters::Location* unsafe_arena_release_location();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 play_time = 6;
  void clear_play_time();
  uint64_t play_time() const;
  void set_play_time(uint64_t value);
  private:
  uint64_t _internal_play_time() const;
  void _internal_set_play_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.CharacterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
  ::sro::characters::Location* location_;
  uint64_t id_;
  uint64_t play_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit constexpr Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Location& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // string world = 1;
  void clear_world();
  const std::string& world() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_world(ArgT0&& arg0, ArgT... args);
  std::string* mutable_world();
  PROTOBUF_NODISCARD std::string* release_world();
  void set_allocated_world(std::string* world);
  private:
  const std::string& _internal_world() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world(const std::string& value);
  std::string* _internal_mutable_world();
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr world_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class CharactersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.CharactersResponse) */ {
 public:
  inline CharactersResponse() : CharactersResponse(nullptr) {}
  ~CharactersResponse() override;
  explicit constexpr CharactersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharactersResponse(const CharactersResponse& from);
  CharactersResponse(CharactersResponse&& from) noexcept
    : CharactersResponse() {
    *this = ::std::move(from);
  }

  inline CharactersResponse& operator=(const CharactersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharactersResponse& operator=(CharactersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharactersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharactersResponse* internal_default_instance() {
    return reinterpret_cast<const CharactersResponse*>(
               &_CharactersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CharactersResponse& a, CharactersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CharactersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharactersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharactersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharactersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharactersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CharactersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharactersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.CharactersResponse";
  }
  protected:
  explicit CharactersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .sro.characters.CharacterResponse characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::sro::characters::CharacterResponse* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::CharacterResponse >*
      mutable_characters();
  private:
  const ::sro::characters::CharacterResponse& _internal_characters(int index) const;
  ::sro::characters::CharacterResponse* _internal_add_characters();
  public:
  const ::sro::characters::CharacterResponse& characters(int index) const;
  ::sro::characters::CharacterResponse* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::CharacterResponse >&
      characters() const;

  // @@protoc_insertion_point(class_scope:sro.characters.CharactersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::CharacterResponse > characters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class Gender final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.Gender) */ {
 public:
  inline Gender() : Gender(nullptr) {}
  ~Gender() override;
  explicit constexpr Gender(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gender(const Gender& from);
  Gender(Gender&& from) noexcept
    : Gender() {
    *this = ::std::move(from);
  }

  inline Gender& operator=(const Gender& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gender& operator=(Gender&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gender& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gender* internal_default_instance() {
    return reinterpret_cast<const Gender*>(
               &_Gender_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Gender& a, Gender& b) {
    a.Swap(&b);
  }
  inline void Swap(Gender* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gender* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gender* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gender>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gender& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Gender& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gender* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.Gender";
  }
  protected:
  explicit Gender(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.Gender)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class Realm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.Realm) */ {
 public:
  inline Realm() : Realm(nullptr) {}
  ~Realm() override;
  explicit constexpr Realm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Realm(const Realm& from);
  Realm(Realm&& from) noexcept
    : Realm() {
    *this = ::std::move(from);
  }

  inline Realm& operator=(const Realm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Realm& operator=(Realm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Realm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Realm* internal_default_instance() {
    return reinterpret_cast<const Realm*>(
               &_Realm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Realm& a, Realm& b) {
    a.Swap(&b);
  }
  inline void Swap(Realm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Realm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Realm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Realm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Realm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Realm& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Realm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.Realm";
  }
  protected:
  explicit Realm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:sro.characters.Realm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class Genders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.Genders) */ {
 public:
  inline Genders() : Genders(nullptr) {}
  ~Genders() override;
  explicit constexpr Genders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Genders(const Genders& from);
  Genders(Genders&& from) noexcept
    : Genders() {
    *this = ::std::move(from);
  }

  inline Genders& operator=(const Genders& from) {
    CopyFrom(from);
    return *this;
  }
  inline Genders& operator=(Genders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Genders& default_instance() {
    return *internal_default_instance();
  }
  static inline const Genders* internal_default_instance() {
    return reinterpret_cast<const Genders*>(
               &_Genders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Genders& a, Genders& b) {
    a.Swap(&b);
  }
  inline void Swap(Genders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Genders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Genders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Genders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Genders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Genders& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Genders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.Genders";
  }
  protected:
  explicit Genders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGendersFieldNumber = 1,
  };
  // repeated .sro.characters.Gender genders = 1;
  int genders_size() const;
  private:
  int _internal_genders_size() const;
  public:
  void clear_genders();
  ::sro::characters::Gender* mutable_genders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Gender >*
      mutable_genders();
  private:
  const ::sro::characters::Gender& _internal_genders(int index) const;
  ::sro::characters::Gender* _internal_add_genders();
  public:
  const ::sro::characters::Gender& genders(int index) const;
  ::sro::characters::Gender* add_genders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Gender >&
      genders() const;

  // @@protoc_insertion_point(class_scope:sro.characters.Genders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Gender > genders_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// -------------------------------------------------------------------

class Realms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.characters.Realms) */ {
 public:
  inline Realms() : Realms(nullptr) {}
  ~Realms() override;
  explicit constexpr Realms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Realms(const Realms& from);
  Realms(Realms&& from) noexcept
    : Realms() {
    *this = ::std::move(from);
  }

  inline Realms& operator=(const Realms& from) {
    CopyFrom(from);
    return *this;
  }
  inline Realms& operator=(Realms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Realms& default_instance() {
    return *internal_default_instance();
  }
  static inline const Realms* internal_default_instance() {
    return reinterpret_cast<const Realms*>(
               &_Realms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Realms& a, Realms& b) {
    a.Swap(&b);
  }
  inline void Swap(Realms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Realms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Realms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Realms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Realms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Realms& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Realms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.characters.Realms";
  }
  protected:
  explicit Realms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealmsFieldNumber = 1,
  };
  // repeated .sro.characters.Realm realms = 1;
  int realms_size() const;
  private:
  int _internal_realms_size() const;
  public:
  void clear_realms();
  ::sro::characters::Realm* mutable_realms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Realm >*
      mutable_realms();
  private:
  const ::sro::characters::Realm& _internal_realms(int index) const;
  ::sro::characters::Realm* _internal_add_realms();
  public:
  const ::sro::characters::Realm& realms(int index) const;
  ::sro::characters::Realm* add_realms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Realm >&
      realms() const;

  // @@protoc_insertion_point(class_scope:sro.characters.Realms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Realm > realms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sro_2fcharacters_2fcharacters_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayTimeResponse

// uint64 time = 1;
inline void PlayTimeResponse::clear_time() {
  time_ = uint64_t{0u};
}
inline uint64_t PlayTimeResponse::_internal_time() const {
  return time_;
}
inline uint64_t PlayTimeResponse::time() const {
  // @@protoc_insertion_point(field_get:sro.characters.PlayTimeResponse.time)
  return _internal_time();
}
inline void PlayTimeResponse::_internal_set_time(uint64_t value) {
  
  time_ = value;
}
inline void PlayTimeResponse::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:sro.characters.PlayTimeResponse.time)
}

// -------------------------------------------------------------------

// AddPlayTimeRequest

// .sro.characters.CharacterTarget character = 1;
inline bool AddPlayTimeRequest::_internal_has_character() const {
  return this != internal_default_instance() && character_ != nullptr;
}
inline bool AddPlayTimeRequest::has_character() const {
  return _internal_has_character();
}
inline void AddPlayTimeRequest::clear_character() {
  if (GetArenaForAllocation() == nullptr && character_ != nullptr) {
    delete character_;
  }
  character_ = nullptr;
}
inline const ::sro::characters::CharacterTarget& AddPlayTimeRequest::_internal_character() const {
  const ::sro::characters::CharacterTarget* p = character_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::characters::CharacterTarget&>(
      ::sro::characters::_CharacterTarget_default_instance_);
}
inline const ::sro::characters::CharacterTarget& AddPlayTimeRequest::character() const {
  // @@protoc_insertion_point(field_get:sro.characters.AddPlayTimeRequest.character)
  return _internal_character();
}
inline void AddPlayTimeRequest::unsafe_arena_set_allocated_character(
    ::sro::characters::CharacterTarget* character) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(character_);
  }
  character_ = character;
  if (character) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.characters.AddPlayTimeRequest.character)
}
inline ::sro::characters::CharacterTarget* AddPlayTimeRequest::release_character() {
  
  ::sro::characters::CharacterTarget* temp = character_;
  character_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::characters::CharacterTarget* AddPlayTimeRequest::unsafe_arena_release_character() {
  // @@protoc_insertion_point(field_release:sro.characters.AddPlayTimeRequest.character)
  
  ::sro::characters::CharacterTarget* temp = character_;
  character_ = nullptr;
  return temp;
}
inline ::sro::characters::CharacterTarget* AddPlayTimeRequest::_internal_mutable_character() {
  
  if (character_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::characters::CharacterTarget>(GetArenaForAllocation());
    character_ = p;
  }
  return character_;
}
inline ::sro::characters::CharacterTarget* AddPlayTimeRequest::mutable_character() {
  ::sro::characters::CharacterTarget* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:sro.characters.AddPlayTimeRequest.character)
  return _msg;
}
inline void AddPlayTimeRequest::set_allocated_character(::sro::characters::CharacterTarget* character) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete character_;
  }
  if (character) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sro::characters::CharacterTarget>::GetOwningArena(character);
    if (message_arena != submessage_arena) {
      character = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character, submessage_arena);
    }
    
  } else {
    
  }
  character_ = character;
  // @@protoc_insertion_point(field_set_allocated:sro.characters.AddPlayTimeRequest.character)
}

// uint64 time = 2;
inline void AddPlayTimeRequest::clear_time() {
  time_ = uint64_t{0u};
}
inline uint64_t AddPlayTimeRequest::_internal_time() const {
  return time_;
}
inline uint64_t AddPlayTimeRequest::time() const {
  // @@protoc_insertion_point(field_get:sro.characters.AddPlayTimeRequest.time)
  return _internal_time();
}
inline void AddPlayTimeRequest::_internal_set_time(uint64_t value) {
  
  time_ = value;
}
inline void AddPlayTimeRequest::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:sro.characters.AddPlayTimeRequest.time)
}

// -------------------------------------------------------------------

// CreateCharacterRequest

// .sro.UserTarget owner = 1;
inline bool CreateCharacterRequest::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool CreateCharacterRequest::has_owner() const {
  return _internal_has_owner();
}
inline const ::sro::UserTarget& CreateCharacterRequest::_internal_owner() const {
  const ::sro::UserTarget* p = owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::UserTarget&>(
      ::sro::_UserTarget_default_instance_);
}
inline const ::sro::UserTarget& CreateCharacterRequest::owner() const {
  // @@protoc_insertion_point(field_get:sro.characters.CreateCharacterRequest.owner)
  return _internal_owner();
}
inline void CreateCharacterRequest::unsafe_arena_set_allocated_owner(
    ::sro::UserTarget* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.characters.CreateCharacterRequest.owner)
}
inline ::sro::UserTarget* CreateCharacterRequest::release_owner() {
  
  ::sro::UserTarget* temp = owner_;
  owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::UserTarget* CreateCharacterRequest::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:sro.characters.CreateCharacterRequest.owner)
  
  ::sro::UserTarget* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::sro::UserTarget* CreateCharacterRequest::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::UserTarget>(GetArenaForAllocation());
    owner_ = p;
  }
  return owner_;
}
inline ::sro::UserTarget* CreateCharacterRequest::mutable_owner() {
  ::sro::UserTarget* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:sro.characters.CreateCharacterRequest.owner)
  return _msg;
}
inline void CreateCharacterRequest::set_allocated_owner(::sro::UserTarget* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CreateCharacterRequest.owner)
}

// string name = 2;
inline void CreateCharacterRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateCharacterRequest::name() const {
  // @@protoc_insertion_point(field_get:sro.characters.CreateCharacterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCharacterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CreateCharacterRequest.name)
}
inline std::string* CreateCharacterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.characters.CreateCharacterRequest.name)
  return _s;
}
inline const std::string& CreateCharacterRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateCharacterRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::release_name() {
  // @@protoc_insertion_point(field_release:sro.characters.CreateCharacterRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCharacterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CreateCharacterRequest.name)
}

// string gender = 3;
inline void CreateCharacterRequest::clear_gender() {
  gender_.ClearToEmpty();
}
inline const std::string& CreateCharacterRequest::gender() const {
  // @@protoc_insertion_point(field_get:sro.characters.CreateCharacterRequest.gender)
  return _internal_gender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCharacterRequest::set_gender(ArgT0&& arg0, ArgT... args) {
 
 gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CreateCharacterRequest.gender)
}
inline std::string* CreateCharacterRequest::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sro.characters.CreateCharacterRequest.gender)
  return _s;
}
inline const std::string& CreateCharacterRequest::_internal_gender() const {
  return gender_.Get();
}
inline void CreateCharacterRequest::_internal_set_gender(const std::string& value) {
  
  gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::_internal_mutable_gender() {
  
  return gender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::release_gender() {
  // @@protoc_insertion_point(field_release:sro.characters.CreateCharacterRequest.gender)
  return gender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCharacterRequest::set_allocated_gender(std::string* gender) {
  if (gender != nullptr) {
    
  } else {
    
  }
  gender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CreateCharacterRequest.gender)
}

// string realm = 4;
inline void CreateCharacterRequest::clear_realm() {
  realm_.ClearToEmpty();
}
inline const std::string& CreateCharacterRequest::realm() const {
  // @@protoc_insertion_point(field_get:sro.characters.CreateCharacterRequest.realm)
  return _internal_realm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCharacterRequest::set_realm(ArgT0&& arg0, ArgT... args) {
 
 realm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CreateCharacterRequest.realm)
}
inline std::string* CreateCharacterRequest::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sro.characters.CreateCharacterRequest.realm)
  return _s;
}
inline const std::string& CreateCharacterRequest::_internal_realm() const {
  return realm_.Get();
}
inline void CreateCharacterRequest::_internal_set_realm(const std::string& value) {
  
  realm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::_internal_mutable_realm() {
  
  return realm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::release_realm() {
  // @@protoc_insertion_point(field_release:sro.characters.CreateCharacterRequest.realm)
  return realm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCharacterRequest::set_allocated_realm(std::string* realm) {
  if (realm != nullptr) {
    
  } else {
    
  }
  realm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), realm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (realm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    realm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CreateCharacterRequest.realm)
}

// -------------------------------------------------------------------

// CharacterTarget

// uint64 id = 1;
inline bool CharacterTarget::_internal_has_id() const {
  return target_case() == kId;
}
inline bool CharacterTarget::has_id() const {
  return _internal_has_id();
}
inline void CharacterTarget::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void CharacterTarget::clear_id() {
  if (_internal_has_id()) {
    target_.id_ = uint64_t{0u};
    clear_has_target();
  }
}
inline uint64_t CharacterTarget::_internal_id() const {
  if (_internal_has_id()) {
    return target_.id_;
  }
  return uint64_t{0u};
}
inline void CharacterTarget::_internal_set_id(uint64_t value) {
  if (!_internal_has_id()) {
    clear_target();
    set_has_id();
  }
  target_.id_ = value;
}
inline uint64_t CharacterTarget::id() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterTarget.id)
  return _internal_id();
}
inline void CharacterTarget::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sro.characters.CharacterTarget.id)
}

// string name = 2;
inline bool CharacterTarget::_internal_has_name() const {
  return target_case() == kName;
}
inline bool CharacterTarget::has_name() const {
  return _internal_has_name();
}
inline void CharacterTarget::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void CharacterTarget::clear_name() {
  if (_internal_has_name()) {
    target_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_target();
  }
}
inline const std::string& CharacterTarget::name() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterTarget.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void CharacterTarget::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_target();
    set_has_name();
    target_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  target_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CharacterTarget.name)
}
inline std::string* CharacterTarget::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.characters.CharacterTarget.name)
  return _s;
}
inline const std::string& CharacterTarget::_internal_name() const {
  if (_internal_has_name()) {
    return target_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CharacterTarget::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_target();
    set_has_name();
    target_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  target_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CharacterTarget::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_target();
    set_has_name();
    target_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return target_.name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CharacterTarget::release_name() {
  // @@protoc_insertion_point(field_release:sro.characters.CharacterTarget.name)
  if (_internal_has_name()) {
    clear_has_target();
    return target_.name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CharacterTarget::set_allocated_name(std::string* name) {
  if (has_target()) {
    clear_target();
  }
  if (name != nullptr) {
    set_has_name();
    target_.name_.UnsafeSetDefault(name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CharacterTarget.name)
}

inline bool CharacterTarget::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void CharacterTarget::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline CharacterTarget::TargetCase CharacterTarget::target_case() const {
  return CharacterTarget::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EditCharacterRequest

// .sro.characters.CharacterTarget target = 1;
inline bool EditCharacterRequest::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool EditCharacterRequest::has_target() const {
  return _internal_has_target();
}
inline void EditCharacterRequest::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::sro::characters::CharacterTarget& EditCharacterRequest::_internal_target() const {
  const ::sro::characters::CharacterTarget* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::characters::CharacterTarget&>(
      ::sro::characters::_CharacterTarget_default_instance_);
}
inline const ::sro::characters::CharacterTarget& EditCharacterRequest::target() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.target)
  return _internal_target();
}
inline void EditCharacterRequest::unsafe_arena_set_allocated_target(
    ::sro::characters::CharacterTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.characters.EditCharacterRequest.target)
}
inline ::sro::characters::CharacterTarget* EditCharacterRequest::release_target() {
  
  ::sro::characters::CharacterTarget* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::characters::CharacterTarget* EditCharacterRequest::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:sro.characters.EditCharacterRequest.target)
  
  ::sro::characters::CharacterTarget* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::sro::characters::CharacterTarget* EditCharacterRequest::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::characters::CharacterTarget>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::sro::characters::CharacterTarget* EditCharacterRequest::mutable_target() {
  ::sro::characters::CharacterTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:sro.characters.EditCharacterRequest.target)
  return _msg;
}
inline void EditCharacterRequest::set_allocated_target(::sro::characters::CharacterTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sro::characters::CharacterTarget>::GetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:sro.characters.EditCharacterRequest.target)
}

// optional string owner_id = 3;
inline bool EditCharacterRequest::_internal_has_owner_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EditCharacterRequest::has_owner_id() const {
  return _internal_has_owner_id();
}
inline void EditCharacterRequest::clear_owner_id() {
  owner_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EditCharacterRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCharacterRequest::set_owner_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.EditCharacterRequest.owner_id)
}
inline std::string* EditCharacterRequest::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:sro.characters.EditCharacterRequest.owner_id)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_owner_id() const {
  return owner_id_.Get();
}
inline void EditCharacterRequest::_internal_set_owner_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_owner_id() {
  _has_bits_[0] |= 0x00000001u;
  return owner_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:sro.characters.EditCharacterRequest.owner_id)
  if (!_internal_has_owner_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = owner_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditCharacterRequest::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  owner_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.EditCharacterRequest.owner_id)
}

// optional string new_name = 4;
inline bool EditCharacterRequest::_internal_has_new_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EditCharacterRequest::has_new_name() const {
  return _internal_has_new_name();
}
inline void EditCharacterRequest::clear_new_name() {
  new_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EditCharacterRequest::new_name() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.new_name)
  return _internal_new_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCharacterRequest::set_new_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 new_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.EditCharacterRequest.new_name)
}
inline std::string* EditCharacterRequest::mutable_new_name() {
  std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:sro.characters.EditCharacterRequest.new_name)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_new_name() const {
  return new_name_.Get();
}
inline void EditCharacterRequest::_internal_set_new_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  new_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_new_name() {
  _has_bits_[0] |= 0x00000002u;
  return new_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_new_name() {
  // @@protoc_insertion_point(field_release:sro.characters.EditCharacterRequest.new_name)
  if (!_internal_has_new_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = new_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditCharacterRequest::set_allocated_new_name(std::string* new_name) {
  if (new_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.EditCharacterRequest.new_name)
}

// optional string gender = 5;
inline bool EditCharacterRequest::_internal_has_gender() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EditCharacterRequest::has_gender() const {
  return _internal_has_gender();
}
inline void EditCharacterRequest::clear_gender() {
  gender_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EditCharacterRequest::gender() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.gender)
  return _internal_gender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCharacterRequest::set_gender(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.EditCharacterRequest.gender)
}
inline std::string* EditCharacterRequest::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sro.characters.EditCharacterRequest.gender)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_gender() const {
  return gender_.Get();
}
inline void EditCharacterRequest::_internal_set_gender(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_gender() {
  _has_bits_[0] |= 0x00000004u;
  return gender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_gender() {
  // @@protoc_insertion_point(field_release:sro.characters.EditCharacterRequest.gender)
  if (!_internal_has_gender()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = gender_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditCharacterRequest::set_allocated_gender(std::string* gender) {
  if (gender != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.EditCharacterRequest.gender)
}

// optional string realm = 6;
inline bool EditCharacterRequest::_internal_has_realm() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EditCharacterRequest::has_realm() const {
  return _internal_has_realm();
}
inline void EditCharacterRequest::clear_realm() {
  realm_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& EditCharacterRequest::realm() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.realm)
  return _internal_realm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCharacterRequest::set_realm(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 realm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.EditCharacterRequest.realm)
}
inline std::string* EditCharacterRequest::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sro.characters.EditCharacterRequest.realm)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_realm() const {
  return realm_.Get();
}
inline void EditCharacterRequest::_internal_set_realm(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  realm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_realm() {
  _has_bits_[0] |= 0x00000008u;
  return realm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_realm() {
  // @@protoc_insertion_point(field_release:sro.characters.EditCharacterRequest.realm)
  if (!_internal_has_realm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = realm_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (realm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    realm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditCharacterRequest::set_allocated_realm(std::string* realm) {
  if (realm != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  realm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), realm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (realm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    realm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.EditCharacterRequest.realm)
}

// optional uint64 play_time = 7;
inline bool EditCharacterRequest::_internal_has_play_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EditCharacterRequest::has_play_time() const {
  return _internal_has_play_time();
}
inline void EditCharacterRequest::clear_play_time() {
  play_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t EditCharacterRequest::_internal_play_time() const {
  return play_time_;
}
inline uint64_t EditCharacterRequest::play_time() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.play_time)
  return _internal_play_time();
}
inline void EditCharacterRequest::_internal_set_play_time(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  play_time_ = value;
}
inline void EditCharacterRequest::set_play_time(uint64_t value) {
  _internal_set_play_time(value);
  // @@protoc_insertion_point(field_set:sro.characters.EditCharacterRequest.play_time)
}

// optional .sro.characters.Location location = 8;
inline bool EditCharacterRequest::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || location_ != nullptr);
  return value;
}
inline bool EditCharacterRequest::has_location() const {
  return _internal_has_location();
}
inline void EditCharacterRequest::clear_location() {
  if (location_ != nullptr) location_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::sro::characters::Location& EditCharacterRequest::_internal_location() const {
  const ::sro::characters::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::characters::Location&>(
      ::sro::characters::_Location_default_instance_);
}
inline const ::sro::characters::Location& EditCharacterRequest::location() const {
  // @@protoc_insertion_point(field_get:sro.characters.EditCharacterRequest.location)
  return _internal_location();
}
inline void EditCharacterRequest::unsafe_arena_set_allocated_location(
    ::sro::characters::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.characters.EditCharacterRequest.location)
}
inline ::sro::characters::Location* EditCharacterRequest::release_location() {
  _has_bits_[0] &= ~0x00000010u;
  ::sro::characters::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::characters::Location* EditCharacterRequest::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:sro.characters.EditCharacterRequest.location)
  _has_bits_[0] &= ~0x00000010u;
  ::sro::characters::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::sro::characters::Location* EditCharacterRequest::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000010u;
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::characters::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::sro::characters::Location* EditCharacterRequest::mutable_location() {
  ::sro::characters::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sro.characters.EditCharacterRequest.location)
  return _msg;
}
inline void EditCharacterRequest::set_allocated_location(::sro::characters::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sro::characters::Location>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:sro.characters.EditCharacterRequest.location)
}

// -------------------------------------------------------------------

// CharacterResponse

// uint64 id = 1;
inline void CharacterResponse::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t CharacterResponse::_internal_id() const {
  return id_;
}
inline uint64_t CharacterResponse::id() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.id)
  return _internal_id();
}
inline void CharacterResponse::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void CharacterResponse::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sro.characters.CharacterResponse.id)
}

// string owner = 2;
inline void CharacterResponse::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& CharacterResponse::owner() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterResponse::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CharacterResponse.owner)
}
inline std::string* CharacterResponse::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:sro.characters.CharacterResponse.owner)
  return _s;
}
inline const std::string& CharacterResponse::_internal_owner() const {
  return owner_.Get();
}
inline void CharacterResponse::_internal_set_owner(const std::string& value) {
  
  owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CharacterResponse::_internal_mutable_owner() {
  
  return owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CharacterResponse::release_owner() {
  // @@protoc_insertion_point(field_release:sro.characters.CharacterResponse.owner)
  return owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CharacterResponse::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CharacterResponse.owner)
}

// string name = 3;
inline void CharacterResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CharacterResponse::name() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CharacterResponse.name)
}
inline std::string* CharacterResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.characters.CharacterResponse.name)
  return _s;
}
inline const std::string& CharacterResponse::_internal_name() const {
  return name_.Get();
}
inline void CharacterResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CharacterResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CharacterResponse::release_name() {
  // @@protoc_insertion_point(field_release:sro.characters.CharacterResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CharacterResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CharacterResponse.name)
}

// string gender = 4;
inline void CharacterResponse::clear_gender() {
  gender_.ClearToEmpty();
}
inline const std::string& CharacterResponse::gender() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.gender)
  return _internal_gender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterResponse::set_gender(ArgT0&& arg0, ArgT... args) {
 
 gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CharacterResponse.gender)
}
inline std::string* CharacterResponse::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sro.characters.CharacterResponse.gender)
  return _s;
}
inline const std::string& CharacterResponse::_internal_gender() const {
  return gender_.Get();
}
inline void CharacterResponse::_internal_set_gender(const std::string& value) {
  
  gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CharacterResponse::_internal_mutable_gender() {
  
  return gender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CharacterResponse::release_gender() {
  // @@protoc_insertion_point(field_release:sro.characters.CharacterResponse.gender)
  return gender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CharacterResponse::set_allocated_gender(std::string* gender) {
  if (gender != nullptr) {
    
  } else {
    
  }
  gender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CharacterResponse.gender)
}

// string realm = 5;
inline void CharacterResponse::clear_realm() {
  realm_.ClearToEmpty();
}
inline const std::string& CharacterResponse::realm() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.realm)
  return _internal_realm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterResponse::set_realm(ArgT0&& arg0, ArgT... args) {
 
 realm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.CharacterResponse.realm)
}
inline std::string* CharacterResponse::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sro.characters.CharacterResponse.realm)
  return _s;
}
inline const std::string& CharacterResponse::_internal_realm() const {
  return realm_.Get();
}
inline void CharacterResponse::_internal_set_realm(const std::string& value) {
  
  realm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CharacterResponse::_internal_mutable_realm() {
  
  return realm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CharacterResponse::release_realm() {
  // @@protoc_insertion_point(field_release:sro.characters.CharacterResponse.realm)
  return realm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CharacterResponse::set_allocated_realm(std::string* realm) {
  if (realm != nullptr) {
    
  } else {
    
  }
  realm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), realm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (realm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    realm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CharacterResponse.realm)
}

// uint64 play_time = 6;
inline void CharacterResponse::clear_play_time() {
  play_time_ = uint64_t{0u};
}
inline uint64_t CharacterResponse::_internal_play_time() const {
  return play_time_;
}
inline uint64_t CharacterResponse::play_time() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.play_time)
  return _internal_play_time();
}
inline void CharacterResponse::_internal_set_play_time(uint64_t value) {
  
  play_time_ = value;
}
inline void CharacterResponse::set_play_time(uint64_t value) {
  _internal_set_play_time(value);
  // @@protoc_insertion_point(field_set:sro.characters.CharacterResponse.play_time)
}

// .sro.characters.Location location = 8;
inline bool CharacterResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool CharacterResponse::has_location() const {
  return _internal_has_location();
}
inline void CharacterResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::sro::characters::Location& CharacterResponse::_internal_location() const {
  const ::sro::characters::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::characters::Location&>(
      ::sro::characters::_Location_default_instance_);
}
inline const ::sro::characters::Location& CharacterResponse::location() const {
  // @@protoc_insertion_point(field_get:sro.characters.CharacterResponse.location)
  return _internal_location();
}
inline void CharacterResponse::unsafe_arena_set_allocated_location(
    ::sro::characters::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.characters.CharacterResponse.location)
}
inline ::sro::characters::Location* CharacterResponse::release_location() {
  
  ::sro::characters::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::characters::Location* CharacterResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:sro.characters.CharacterResponse.location)
  
  ::sro::characters::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::sro::characters::Location* CharacterResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::characters::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::sro::characters::Location* CharacterResponse::mutable_location() {
  ::sro::characters::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sro.characters.CharacterResponse.location)
  return _msg;
}
inline void CharacterResponse::set_allocated_location(::sro::characters::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sro::characters::Location>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:sro.characters.CharacterResponse.location)
}

// -------------------------------------------------------------------

// Location

// string world = 1;
inline void Location::clear_world() {
  world_.ClearToEmpty();
}
inline const std::string& Location::world() const {
  // @@protoc_insertion_point(field_get:sro.characters.Location.world)
  return _internal_world();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_world(ArgT0&& arg0, ArgT... args) {
 
 world_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.Location.world)
}
inline std::string* Location::mutable_world() {
  std::string* _s = _internal_mutable_world();
  // @@protoc_insertion_point(field_mutable:sro.characters.Location.world)
  return _s;
}
inline const std::string& Location::_internal_world() const {
  return world_.Get();
}
inline void Location::_internal_set_world(const std::string& value) {
  
  world_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_world() {
  
  return world_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_world() {
  // @@protoc_insertion_point(field_release:sro.characters.Location.world)
  return world_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location::set_allocated_world(std::string* world) {
  if (world != nullptr) {
    
  } else {
    
  }
  world_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), world,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (world_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    world_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.Location.world)
}

// float x = 2;
inline void Location::clear_x() {
  x_ = 0;
}
inline float Location::_internal_x() const {
  return x_;
}
inline float Location::x() const {
  // @@protoc_insertion_point(field_get:sro.characters.Location.x)
  return _internal_x();
}
inline void Location::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Location::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sro.characters.Location.x)
}

// float y = 3;
inline void Location::clear_y() {
  y_ = 0;
}
inline float Location::_internal_y() const {
  return y_;
}
inline float Location::y() const {
  // @@protoc_insertion_point(field_get:sro.characters.Location.y)
  return _internal_y();
}
inline void Location::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Location::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sro.characters.Location.y)
}

// float z = 4;
inline void Location::clear_z() {
  z_ = 0;
}
inline float Location::_internal_z() const {
  return z_;
}
inline float Location::z() const {
  // @@protoc_insertion_point(field_get:sro.characters.Location.z)
  return _internal_z();
}
inline void Location::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Location::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sro.characters.Location.z)
}

// -------------------------------------------------------------------

// CharactersResponse

// repeated .sro.characters.CharacterResponse characters = 1;
inline int CharactersResponse::_internal_characters_size() const {
  return characters_.size();
}
inline int CharactersResponse::characters_size() const {
  return _internal_characters_size();
}
inline void CharactersResponse::clear_characters() {
  characters_.Clear();
}
inline ::sro::characters::CharacterResponse* CharactersResponse::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:sro.characters.CharactersResponse.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::CharacterResponse >*
CharactersResponse::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:sro.characters.CharactersResponse.characters)
  return &characters_;
}
inline const ::sro::characters::CharacterResponse& CharactersResponse::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::sro::characters::CharacterResponse& CharactersResponse::characters(int index) const {
  // @@protoc_insertion_point(field_get:sro.characters.CharactersResponse.characters)
  return _internal_characters(index);
}
inline ::sro::characters::CharacterResponse* CharactersResponse::_internal_add_characters() {
  return characters_.Add();
}
inline ::sro::characters::CharacterResponse* CharactersResponse::add_characters() {
  ::sro::characters::CharacterResponse* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:sro.characters.CharactersResponse.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::CharacterResponse >&
CharactersResponse::characters() const {
  // @@protoc_insertion_point(field_list:sro.characters.CharactersResponse.characters)
  return characters_;
}

// -------------------------------------------------------------------

// Gender

// string name = 1;
inline void Gender::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Gender::name() const {
  // @@protoc_insertion_point(field_get:sro.characters.Gender.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gender::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.Gender.name)
}
inline std::string* Gender::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.characters.Gender.name)
  return _s;
}
inline const std::string& Gender::_internal_name() const {
  return name_.Get();
}
inline void Gender::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gender::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gender::release_name() {
  // @@protoc_insertion_point(field_release:sro.characters.Gender.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gender::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.Gender.name)
}

// -------------------------------------------------------------------

// Realm

// string name = 1;
inline void Realm::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Realm::name() const {
  // @@protoc_insertion_point(field_get:sro.characters.Realm.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Realm::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.characters.Realm.name)
}
inline std::string* Realm::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.characters.Realm.name)
  return _s;
}
inline const std::string& Realm::_internal_name() const {
  return name_.Get();
}
inline void Realm::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Realm::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Realm::release_name() {
  // @@protoc_insertion_point(field_release:sro.characters.Realm.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Realm::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.characters.Realm.name)
}

// -------------------------------------------------------------------

// Genders

// repeated .sro.characters.Gender genders = 1;
inline int Genders::_internal_genders_size() const {
  return genders_.size();
}
inline int Genders::genders_size() const {
  return _internal_genders_size();
}
inline void Genders::clear_genders() {
  genders_.Clear();
}
inline ::sro::characters::Gender* Genders::mutable_genders(int index) {
  // @@protoc_insertion_point(field_mutable:sro.characters.Genders.genders)
  return genders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Gender >*
Genders::mutable_genders() {
  // @@protoc_insertion_point(field_mutable_list:sro.characters.Genders.genders)
  return &genders_;
}
inline const ::sro::characters::Gender& Genders::_internal_genders(int index) const {
  return genders_.Get(index);
}
inline const ::sro::characters::Gender& Genders::genders(int index) const {
  // @@protoc_insertion_point(field_get:sro.characters.Genders.genders)
  return _internal_genders(index);
}
inline ::sro::characters::Gender* Genders::_internal_add_genders() {
  return genders_.Add();
}
inline ::sro::characters::Gender* Genders::add_genders() {
  ::sro::characters::Gender* _add = _internal_add_genders();
  // @@protoc_insertion_point(field_add:sro.characters.Genders.genders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Gender >&
Genders::genders() const {
  // @@protoc_insertion_point(field_list:sro.characters.Genders.genders)
  return genders_;
}

// -------------------------------------------------------------------

// Realms

// repeated .sro.characters.Realm realms = 1;
inline int Realms::_internal_realms_size() const {
  return realms_.size();
}
inline int Realms::realms_size() const {
  return _internal_realms_size();
}
inline void Realms::clear_realms() {
  realms_.Clear();
}
inline ::sro::characters::Realm* Realms::mutable_realms(int index) {
  // @@protoc_insertion_point(field_mutable:sro.characters.Realms.realms)
  return realms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Realm >*
Realms::mutable_realms() {
  // @@protoc_insertion_point(field_mutable_list:sro.characters.Realms.realms)
  return &realms_;
}
inline const ::sro::characters::Realm& Realms::_internal_realms(int index) const {
  return realms_.Get(index);
}
inline const ::sro::characters::Realm& Realms::realms(int index) const {
  // @@protoc_insertion_point(field_get:sro.characters.Realms.realms)
  return _internal_realms(index);
}
inline ::sro::characters::Realm* Realms::_internal_add_realms() {
  return realms_.Add();
}
inline ::sro::characters::Realm* Realms::add_realms() {
  ::sro::characters::Realm* _add = _internal_add_realms();
  // @@protoc_insertion_point(field_add:sro.characters.Realms.realms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::characters::Realm >&
Realms::realms() const {
  // @@protoc_insertion_point(field_list:sro.characters.Realms.realms)
  return realms_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace characters
}  // namespace sro

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sro_2fcharacters_2fcharacters_2eproto
