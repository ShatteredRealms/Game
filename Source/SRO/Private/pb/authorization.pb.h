#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: authorization.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_authorization_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_authorization_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_authorization_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_authorization_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_authorization_2eproto;
namespace sro {
namespace accounts {
class AuthorizationMessage;
struct AuthorizationMessageDefaultTypeInternal;
extern AuthorizationMessageDefaultTypeInternal _AuthorizationMessage_default_instance_;
class IDMessage;
struct IDMessageDefaultTypeInternal;
extern IDMessageDefaultTypeInternal _IDMessage_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class UserPermission;
struct UserPermissionDefaultTypeInternal;
extern UserPermissionDefaultTypeInternal _UserPermission_default_instance_;
class UserPermissions;
struct UserPermissionsDefaultTypeInternal;
extern UserPermissionsDefaultTypeInternal _UserPermissions_default_instance_;
class UserRole;
struct UserRoleDefaultTypeInternal;
extern UserRoleDefaultTypeInternal _UserRole_default_instance_;
class UserRoles;
struct UserRolesDefaultTypeInternal;
extern UserRolesDefaultTypeInternal _UserRoles_default_instance_;
}  // namespace accounts
}  // namespace sro
PROTOBUF_NAMESPACE_OPEN
template<> ::sro::accounts::AuthorizationMessage* Arena::CreateMaybeMessage<::sro::accounts::AuthorizationMessage>(Arena*);
template<> ::sro::accounts::IDMessage* Arena::CreateMaybeMessage<::sro::accounts::IDMessage>(Arena*);
template<> ::sro::accounts::Permission* Arena::CreateMaybeMessage<::sro::accounts::Permission>(Arena*);
template<> ::sro::accounts::UserPermission* Arena::CreateMaybeMessage<::sro::accounts::UserPermission>(Arena*);
template<> ::sro::accounts::UserPermissions* Arena::CreateMaybeMessage<::sro::accounts::UserPermissions>(Arena*);
template<> ::sro::accounts::UserRole* Arena::CreateMaybeMessage<::sro::accounts::UserRole>(Arena*);
template<> ::sro::accounts::UserRoles* Arena::CreateMaybeMessage<::sro::accounts::UserRoles>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sro {
namespace accounts {

// ===================================================================

class IDMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.IDMessage) */ {
 public:
  inline IDMessage() : IDMessage(nullptr) {}
  ~IDMessage() override;
  explicit constexpr IDMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IDMessage(const IDMessage& from);
  IDMessage(IDMessage&& from) noexcept
    : IDMessage() {
    *this = ::std::move(from);
  }

  inline IDMessage& operator=(const IDMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline IDMessage& operator=(IDMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IDMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const IDMessage* internal_default_instance() {
    return reinterpret_cast<const IDMessage*>(
               &_IDMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IDMessage& a, IDMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(IDMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IDMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IDMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IDMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IDMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IDMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IDMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.IDMessage";
  }
  protected:
  explicit IDMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.accounts.IDMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// -------------------------------------------------------------------

class Permission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  explicit constexpr Permission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Permission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.Permission";
  }
  protected:
  explicit Permission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 1,
  };
  // .google.protobuf.StringValue permission = 1;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& permission() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_permission();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_permission();
  void set_allocated_permission(::PROTOBUF_NAMESPACE_ID::StringValue* permission);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_permission() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::PROTOBUF_NAMESPACE_ID::StringValue* permission);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_permission();

  // @@protoc_insertion_point(class_scope:sro.accounts.Permission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* permission_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// -------------------------------------------------------------------

class UserPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.UserPermission) */ {
 public:
  inline UserPermission() : UserPermission(nullptr) {}
  ~UserPermission() override;
  explicit constexpr UserPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPermission(const UserPermission& from);
  UserPermission(UserPermission&& from) noexcept
    : UserPermission() {
    *this = ::std::move(from);
  }

  inline UserPermission& operator=(const UserPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPermission& operator=(UserPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPermission* internal_default_instance() {
    return reinterpret_cast<const UserPermission*>(
               &_UserPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserPermission& a, UserPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserPermission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.UserPermission";
  }
  protected:
  explicit UserPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 1,
    kOtherFieldNumber = 2,
  };
  // .google.protobuf.StringValue permission = 1;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& permission() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_permission();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_permission();
  void set_allocated_permission(::PROTOBUF_NAMESPACE_ID::StringValue* permission);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_permission() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::PROTOBUF_NAMESPACE_ID::StringValue* permission);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_permission();

  // bool other = 2;
  void clear_other();
  bool other() const;
  void set_other(bool value);
  private:
  bool _internal_other() const;
  void _internal_set_other(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sro.accounts.UserPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* permission_;
  bool other_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// -------------------------------------------------------------------

class UserPermissions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.UserPermissions) */ {
 public:
  inline UserPermissions() : UserPermissions(nullptr) {}
  ~UserPermissions() override;
  explicit constexpr UserPermissions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPermissions(const UserPermissions& from);
  UserPermissions(UserPermissions&& from) noexcept
    : UserPermissions() {
    *this = ::std::move(from);
  }

  inline UserPermissions& operator=(const UserPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPermissions& operator=(UserPermissions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPermissions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPermissions* internal_default_instance() {
    return reinterpret_cast<const UserPermissions*>(
               &_UserPermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserPermissions& a, UserPermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPermissions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPermissions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserPermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserPermissions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPermissions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserPermissions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPermissions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.UserPermissions";
  }
  protected:
  explicit UserPermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .sro.accounts.UserPermission permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::sro::accounts::UserPermission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >*
      mutable_permissions();
  private:
  const ::sro::accounts::UserPermission& _internal_permissions(int index) const;
  ::sro::accounts::UserPermission* _internal_add_permissions();
  public:
  const ::sro::accounts::UserPermission& permissions(int index) const;
  ::sro::accounts::UserPermission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:sro.accounts.UserPermissions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission > permissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// -------------------------------------------------------------------

class UserRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.UserRole) */ {
 public:
  inline UserRole() : UserRole(nullptr) {}
  ~UserRole() override;
  explicit constexpr UserRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRole(const UserRole& from);
  UserRole(UserRole&& from) noexcept
    : UserRole() {
    *this = ::std::move(from);
  }

  inline UserRole& operator=(const UserRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRole& operator=(UserRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRole* internal_default_instance() {
    return reinterpret_cast<const UserRole*>(
               &_UserRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserRole& a, UserRole& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserRole& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.UserRole";
  }
  protected:
  explicit UserRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .sro.accounts.UserPermission permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::sro::accounts::UserPermission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >*
      mutable_permissions();
  private:
  const ::sro::accounts::UserPermission& _internal_permissions(int index) const;
  ::sro::accounts::UserPermission* _internal_add_permissions();
  public:
  const ::sro::accounts::UserPermission& permissions(int index) const;
  ::sro::accounts::UserPermission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >&
      permissions() const;

  // .google.protobuf.StringValue name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& name() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_name();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_name();
  void set_allocated_name(::PROTOBUF_NAMESPACE_ID::StringValue* name);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_name() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::PROTOBUF_NAMESPACE_ID::StringValue* name);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_name();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.accounts.UserRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission > permissions_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* name_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// -------------------------------------------------------------------

class UserRoles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.UserRoles) */ {
 public:
  inline UserRoles() : UserRoles(nullptr) {}
  ~UserRoles() override;
  explicit constexpr UserRoles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRoles(const UserRoles& from);
  UserRoles(UserRoles&& from) noexcept
    : UserRoles() {
    *this = ::std::move(from);
  }

  inline UserRoles& operator=(const UserRoles& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRoles& operator=(UserRoles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRoles& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRoles* internal_default_instance() {
    return reinterpret_cast<const UserRoles*>(
               &_UserRoles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserRoles& a, UserRoles& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRoles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRoles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRoles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRoles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRoles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserRoles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRoles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.UserRoles";
  }
  protected:
  explicit UserRoles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 1,
  };
  // repeated .sro.accounts.UserRole roles = 1;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::sro::accounts::UserRole* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >*
      mutable_roles();
  private:
  const ::sro::accounts::UserRole& _internal_roles(int index) const;
  ::sro::accounts::UserRole* _internal_add_roles();
  public:
  const ::sro::accounts::UserRole& roles(int index) const;
  ::sro::accounts::UserRole* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >&
      roles() const;

  // @@protoc_insertion_point(class_scope:sro.accounts.UserRoles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole > roles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// -------------------------------------------------------------------

class AuthorizationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.accounts.AuthorizationMessage) */ {
 public:
  inline AuthorizationMessage() : AuthorizationMessage(nullptr) {}
  ~AuthorizationMessage() override;
  explicit constexpr AuthorizationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizationMessage(const AuthorizationMessage& from);
  AuthorizationMessage(AuthorizationMessage&& from) noexcept
    : AuthorizationMessage() {
    *this = ::std::move(from);
  }

  inline AuthorizationMessage& operator=(const AuthorizationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizationMessage& operator=(AuthorizationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizationMessage* internal_default_instance() {
    return reinterpret_cast<const AuthorizationMessage*>(
               &_AuthorizationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AuthorizationMessage& a, AuthorizationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizationMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizationMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthorizationMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sro.accounts.AuthorizationMessage";
  }
  protected:
  explicit AuthorizationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kPermissionsFieldNumber = 3,
    kUserIdFieldNumber = 1,
  };
  // repeated .sro.accounts.UserRole roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::sro::accounts::UserRole* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >*
      mutable_roles();
  private:
  const ::sro::accounts::UserRole& _internal_roles(int index) const;
  ::sro::accounts::UserRole* _internal_add_roles();
  public:
  const ::sro::accounts::UserRole& roles(int index) const;
  ::sro::accounts::UserRole* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >&
      roles() const;

  // repeated .sro.accounts.UserPermission permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::sro::accounts::UserPermission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >*
      mutable_permissions();
  private:
  const ::sro::accounts::UserPermission& _internal_permissions(int index) const;
  ::sro::accounts::UserPermission* _internal_add_permissions();
  public:
  const ::sro::accounts::UserPermission& permissions(int index) const;
  ::sro::accounts::UserPermission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >&
      permissions() const;

  // uint64 user_id = 1;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sro.accounts.AuthorizationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole > roles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission > permissions_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_authorization_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IDMessage

// uint64 id = 1;
inline void IDMessage::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t IDMessage::_internal_id() const {
  return id_;
}
inline uint64_t IDMessage::id() const {
  // @@protoc_insertion_point(field_get:sro.accounts.IDMessage.id)
  return _internal_id();
}
inline void IDMessage::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void IDMessage::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sro.accounts.IDMessage.id)
}

// -------------------------------------------------------------------

// Permission

// .google.protobuf.StringValue permission = 1;
inline bool Permission::_internal_has_permission() const {
  return this != internal_default_instance() && permission_ != nullptr;
}
inline bool Permission::has_permission() const {
  return _internal_has_permission();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Permission::_internal_permission() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Permission::permission() const {
  // @@protoc_insertion_point(field_get:sro.accounts.Permission.permission)
  return _internal_permission();
}
inline void Permission::unsafe_arena_set_allocated_permission(
    ::PROTOBUF_NAMESPACE_ID::StringValue* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.accounts.Permission.permission)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Permission::release_permission() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = permission_;
  permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Permission::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:sro.accounts.Permission.permission)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Permission::_internal_mutable_permission() {
  
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    permission_ = p;
  }
  return permission_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Permission::mutable_permission() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:sro.accounts.Permission.permission)
  return _msg;
}
inline void Permission::set_allocated_permission(::PROTOBUF_NAMESPACE_ID::StringValue* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:sro.accounts.Permission.permission)
}

// -------------------------------------------------------------------

// UserPermission

// .google.protobuf.StringValue permission = 1;
inline bool UserPermission::_internal_has_permission() const {
  return this != internal_default_instance() && permission_ != nullptr;
}
inline bool UserPermission::has_permission() const {
  return _internal_has_permission();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& UserPermission::_internal_permission() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& UserPermission::permission() const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserPermission.permission)
  return _internal_permission();
}
inline void UserPermission::unsafe_arena_set_allocated_permission(
    ::PROTOBUF_NAMESPACE_ID::StringValue* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.accounts.UserPermission.permission)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserPermission::release_permission() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = permission_;
  permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserPermission::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:sro.accounts.UserPermission.permission)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserPermission::_internal_mutable_permission() {
  
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    permission_ = p;
  }
  return permission_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserPermission::mutable_permission() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:sro.accounts.UserPermission.permission)
  return _msg;
}
inline void UserPermission::set_allocated_permission(::PROTOBUF_NAMESPACE_ID::StringValue* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:sro.accounts.UserPermission.permission)
}

// bool other = 2;
inline void UserPermission::clear_other() {
  other_ = false;
}
inline bool UserPermission::_internal_other() const {
  return other_;
}
inline bool UserPermission::other() const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserPermission.other)
  return _internal_other();
}
inline void UserPermission::_internal_set_other(bool value) {
  
  other_ = value;
}
inline void UserPermission::set_other(bool value) {
  _internal_set_other(value);
  // @@protoc_insertion_point(field_set:sro.accounts.UserPermission.other)
}

// -------------------------------------------------------------------

// UserPermissions

// repeated .sro.accounts.UserPermission permissions = 1;
inline int UserPermissions::_internal_permissions_size() const {
  return permissions_.size();
}
inline int UserPermissions::permissions_size() const {
  return _internal_permissions_size();
}
inline void UserPermissions::clear_permissions() {
  permissions_.Clear();
}
inline ::sro::accounts::UserPermission* UserPermissions::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:sro.accounts.UserPermissions.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >*
UserPermissions::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:sro.accounts.UserPermissions.permissions)
  return &permissions_;
}
inline const ::sro::accounts::UserPermission& UserPermissions::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::sro::accounts::UserPermission& UserPermissions::permissions(int index) const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserPermissions.permissions)
  return _internal_permissions(index);
}
inline ::sro::accounts::UserPermission* UserPermissions::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::sro::accounts::UserPermission* UserPermissions::add_permissions() {
  ::sro::accounts::UserPermission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:sro.accounts.UserPermissions.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >&
UserPermissions::permissions() const {
  // @@protoc_insertion_point(field_list:sro.accounts.UserPermissions.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// UserRole

// uint64 id = 1;
inline void UserRole::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t UserRole::_internal_id() const {
  return id_;
}
inline uint64_t UserRole::id() const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserRole.id)
  return _internal_id();
}
inline void UserRole::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void UserRole::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sro.accounts.UserRole.id)
}

// .google.protobuf.StringValue name = 2;
inline bool UserRole::_internal_has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline bool UserRole::has_name() const {
  return _internal_has_name();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& UserRole::_internal_name() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& UserRole::name() const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserRole.name)
  return _internal_name();
}
inline void UserRole::unsafe_arena_set_allocated_name(
    ::PROTOBUF_NAMESPACE_ID::StringValue* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.accounts.UserRole.name)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserRole::release_name() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserRole::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:sro.accounts.UserRole.name)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserRole::_internal_mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UserRole::mutable_name() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.accounts.UserRole.name)
  return _msg;
}
inline void UserRole::set_allocated_name(::PROTOBUF_NAMESPACE_ID::StringValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:sro.accounts.UserRole.name)
}

// repeated .sro.accounts.UserPermission permissions = 3;
inline int UserRole::_internal_permissions_size() const {
  return permissions_.size();
}
inline int UserRole::permissions_size() const {
  return _internal_permissions_size();
}
inline void UserRole::clear_permissions() {
  permissions_.Clear();
}
inline ::sro::accounts::UserPermission* UserRole::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:sro.accounts.UserRole.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >*
UserRole::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:sro.accounts.UserRole.permissions)
  return &permissions_;
}
inline const ::sro::accounts::UserPermission& UserRole::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::sro::accounts::UserPermission& UserRole::permissions(int index) const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserRole.permissions)
  return _internal_permissions(index);
}
inline ::sro::accounts::UserPermission* UserRole::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::sro::accounts::UserPermission* UserRole::add_permissions() {
  ::sro::accounts::UserPermission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:sro.accounts.UserRole.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >&
UserRole::permissions() const {
  // @@protoc_insertion_point(field_list:sro.accounts.UserRole.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// UserRoles

// repeated .sro.accounts.UserRole roles = 1;
inline int UserRoles::_internal_roles_size() const {
  return roles_.size();
}
inline int UserRoles::roles_size() const {
  return _internal_roles_size();
}
inline void UserRoles::clear_roles() {
  roles_.Clear();
}
inline ::sro::accounts::UserRole* UserRoles::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:sro.accounts.UserRoles.roles)
  return roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >*
UserRoles::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:sro.accounts.UserRoles.roles)
  return &roles_;
}
inline const ::sro::accounts::UserRole& UserRoles::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const ::sro::accounts::UserRole& UserRoles::roles(int index) const {
  // @@protoc_insertion_point(field_get:sro.accounts.UserRoles.roles)
  return _internal_roles(index);
}
inline ::sro::accounts::UserRole* UserRoles::_internal_add_roles() {
  return roles_.Add();
}
inline ::sro::accounts::UserRole* UserRoles::add_roles() {
  ::sro::accounts::UserRole* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:sro.accounts.UserRoles.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >&
UserRoles::roles() const {
  // @@protoc_insertion_point(field_list:sro.accounts.UserRoles.roles)
  return roles_;
}

// -------------------------------------------------------------------

// AuthorizationMessage

// uint64 user_id = 1;
inline void AuthorizationMessage::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t AuthorizationMessage::_internal_user_id() const {
  return user_id_;
}
inline uint64_t AuthorizationMessage::user_id() const {
  // @@protoc_insertion_point(field_get:sro.accounts.AuthorizationMessage.user_id)
  return _internal_user_id();
}
inline void AuthorizationMessage::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void AuthorizationMessage::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:sro.accounts.AuthorizationMessage.user_id)
}

// repeated .sro.accounts.UserRole roles = 2;
inline int AuthorizationMessage::_internal_roles_size() const {
  return roles_.size();
}
inline int AuthorizationMessage::roles_size() const {
  return _internal_roles_size();
}
inline void AuthorizationMessage::clear_roles() {
  roles_.Clear();
}
inline ::sro::accounts::UserRole* AuthorizationMessage::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:sro.accounts.AuthorizationMessage.roles)
  return roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >*
AuthorizationMessage::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:sro.accounts.AuthorizationMessage.roles)
  return &roles_;
}
inline const ::sro::accounts::UserRole& AuthorizationMessage::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const ::sro::accounts::UserRole& AuthorizationMessage::roles(int index) const {
  // @@protoc_insertion_point(field_get:sro.accounts.AuthorizationMessage.roles)
  return _internal_roles(index);
}
inline ::sro::accounts::UserRole* AuthorizationMessage::_internal_add_roles() {
  return roles_.Add();
}
inline ::sro::accounts::UserRole* AuthorizationMessage::add_roles() {
  ::sro::accounts::UserRole* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:sro.accounts.AuthorizationMessage.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserRole >&
AuthorizationMessage::roles() const {
  // @@protoc_insertion_point(field_list:sro.accounts.AuthorizationMessage.roles)
  return roles_;
}

// repeated .sro.accounts.UserPermission permissions = 3;
inline int AuthorizationMessage::_internal_permissions_size() const {
  return permissions_.size();
}
inline int AuthorizationMessage::permissions_size() const {
  return _internal_permissions_size();
}
inline void AuthorizationMessage::clear_permissions() {
  permissions_.Clear();
}
inline ::sro::accounts::UserPermission* AuthorizationMessage::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:sro.accounts.AuthorizationMessage.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >*
AuthorizationMessage::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:sro.accounts.AuthorizationMessage.permissions)
  return &permissions_;
}
inline const ::sro::accounts::UserPermission& AuthorizationMessage::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::sro::accounts::UserPermission& AuthorizationMessage::permissions(int index) const {
  // @@protoc_insertion_point(field_get:sro.accounts.AuthorizationMessage.permissions)
  return _internal_permissions(index);
}
inline ::sro::accounts::UserPermission* AuthorizationMessage::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::sro::accounts::UserPermission* AuthorizationMessage::add_permissions() {
  ::sro::accounts::UserPermission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:sro.accounts.AuthorizationMessage.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::accounts::UserPermission >&
AuthorizationMessage::permissions() const {
  // @@protoc_insertion_point(field_list:sro.accounts.AuthorizationMessage.permissions)
  return permissions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace accounts
}  // namespace sro

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_authorization_2eproto
